debugX = true

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Create the main window
local Window = Rayfield:CreateWindow({
   Name = "Kryp Paid",
   Icon = 0,
   LoadingTitle = "Kryp Paid Interface",
   LoadingSubtitle = "by Shaman Team",
   Theme = "Default",
   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false,
   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil,
      FileName = "KrypPaidConfig"
   },
   Discord = {
      Enabled = false,
      Invite = "",
      RememberJoins = true
   },
   KeySystem = false,
   KeySettings = {
      Title = "Kryp Paid Key System",
      Subtitle = "Enter your key",
      Note = "Obtain your key from the official website.",
      FileName = "KrypPaidKey",
      SaveKey = true,
      GrabKeyFromSite = false,
      Key = {"Hello"}
   }
})

-- Services
local ContextActionService = game:GetService('ContextActionService')
local UserInputService = cloneref and cloneref(game:GetService('UserInputService')) or game:GetService('UserInputService')
local ContentProvider = cloneref and cloneref(game:GetService('ContentProvider')) or game:GetService('ContentProvider')
local TweenService = cloneref and cloneref(game:GetService('TweenService')) or game:GetService('TweenService')
local HttpService = cloneref and cloneref(game:GetService('HttpService')) or game:GetService('HttpService')
local TextService = cloneref and cloneref(game:GetService('TextService')) or game:GetService('TextService')
local RunService = cloneref and cloneref(game:GetService('RunService')) or game:GetService('RunService')
local Lighting = cloneref and cloneref(game:GetService('Lighting')) or game:GetService('Lighting')
local Players = cloneref and cloneref(game:GetService('Players')) or game:GetService('Players')
local CoreGui = cloneref and cloneref(game:GetService('CoreGui')) or game:GetService('CoreGui')
local Debris = cloneref and cloneref(game:GetService('Debris')) or game:GetService('Debris')
local VirtualInputManager = game:GetService("VirtualInputManager")
local GuiService = game:GetService('GuiService')

-- Local Player Variables
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local Stats = game:GetService("Stats")
local clientCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local clientHumanoid = clientCharacter:FindFirstChildOfClass("Humanoid")
local AliveGroup = Workspace:FindFirstChild("Alive")
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Hotbar = PlayerGui:WaitForChild("Hotbar")
local ParryCD = PlayerGui.Hotbar.Block.UIGradient
local AbilityCD = PlayerGui.Hotbar.Ability.UIGradient

-- Original Variables
local Phantom = false
local Tornado_Time = tick()
local Last_Input = UserInputService:GetLastInputType()
local Vector2_Mouse_Location = nil
local Grab_Parry = nil
local Parry_Remote = true
local Parry_Key = nil
local Parry_Arg = nil
local Speed_Divisor_Multiplier = 1.1
local LobbyAP_Speed_Divisor_Multiplier = 1.1
local firstParryFired = false
local ParryThreshold = 2.5
local firstParryType = 'F_Key'
local Previous_Positions = {}
local Parries = 0
local Lerp_Radians = 0
local Last_Warping = tick()
local Previous_Velocity = {}
local Curving = tick()
local Runtime = Workspace.Runtime
local Connections_Manager = {}
local Selected_Parry_Type = "Camera"
local Infinity = false
local Parried = false
local Last_Parry = 0
local AutoParry = true
local Balls = Workspace:WaitForChild('Balls')
local CurrentBall = nil
local InputTask = nil
local RunTime = Workspace:FindFirstChild("Runtime")
local isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
local StrafeSpeed = 36
local Training_Parried = false
local CosmeticsActive = false
local hit_Sound_Enabled = false
local headLoop = nil

-- Visuals Variables
local espEnabled = false
local espConnections = {}
local nameTagsEnabled = false
local nameTagsConnections = {}
local chamsEnabled = false
local chamsConnections = {}
local fullbrightEnabled = false
local originalLighting = {
    Brightness = Lighting.Brightness,
    Ambient = Lighting.Ambient,
    OutdoorAmbient = Lighting.OutdoorAmbient,
    FogEnd = Lighting.FogEnd
}
local crosshairEnabled = false
local crosshairGui = nil

-- New Variables for Additions
local musicPlayer = nil
local skyboxConnection = nil
local shaderConnection = nil
local currentSkybox = nil
local currentShader = nil
local skyColorConnection = nil
local BallPauseEnabled = false
local BallPauseDistanceThreshold = 10

-- Flags Table
local Flags = {}

-- Remote Detection
task.spawn(function()
    for _, value in pairs(getgc()) do
        if type(value) == "function" and islclosure(value) then
            local protos = debug.getprotos(value)
            local upvalues = debug.getupvalues(value)
            local constants = debug.getconstants(value)
            if #protos == 4 and #upvalues == 24 and #constants >= 102 then
                Parry_Key = debug.getupvalue(value, 17)
                Parry_Remote = debug.getupvalue(value, 18)
                Parry_Arg = debug.getconstant(value, 64)
                break
            end
        end
    end
    if not Parry_Remote then
        warn("[Parry Remote Detection] Failed to find Parry_Remote")
    else
        print("[Parry Remote Detection] Success: Remote =", Parry_Remote and Parry_Remote.Name or "nil", "Key =", Parry_Key, "Arg =", Parry_Arg)
    end
end)

-- Utility Functions
local function BlockMovement(actionName, inputState, inputObject)
    return Enum.ContextActionResult.Sink
end

local function updateNavigation(guiObject)
    GuiService.SelectedObject = guiObject
end

local function performFirstPress(parryType)
    if parryType == 'F_Key' then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, nil)
    elseif parryType == 'Left_Click' then
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
    elseif parryType == 'Navigation' then
        local button = Players.LocalPlayer.PlayerGui.Hotbar.Block
        updateNavigation(button)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
        task.wait(0.01)
        updateNavigation(nil)
    end
end

if not LPH_OBFUSCATED then
    function LPH_JIT(Function) return Function end
    function LPH_JIT_MAX(Function) return Function end
    function LPH_NO_VIRTUALIZE(Function) return Function end
end

function create_animation(object, info, value)
    local animation = TweenService:Create(object, info, value)
    animation:Play()
    task.wait(info.Time)
    Debris:AddItem(animation, 0)
    animation:Destroy()
    animation = nil
end

-- Animation Handling
local Animation = {}
Animation.storage = {}
Animation.current = nil
Animation.track = nil

for _, v in pairs(ReplicatedStorage.Misc.Emotes:GetChildren()) do
    if v:IsA("Animation") and v:GetAttribute("EmoteName") then
        local Emote_Name = v:GetAttribute("EmoteName")
        Animation.storage[Emote_Name] = v
    end
end

local Emotes_Data = {}
for Object in pairs(Animation.storage) do
    table.insert(Emotes_Data, Object)
end
table.sort(Emotes_Data)

-- Auto Parry System
local Auto_Parry = {}

function Auto_Parry.Parry_Animation()
    local Parry_Animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild('GrabParry')
    local Current_Sword = LocalPlayer.Character:GetAttribute('CurrentlyEquippedSword')

    if not Current_Sword or not Parry_Animation then
        return
    end

    local Sword_Data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(Current_Sword)

    if not Sword_Data or not Sword_Data['AnimationType'] then
        return
    end

    for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
        if object.Name == Sword_Data['AnimationType'] then
            if object:FindFirstChild('GrabParry') or object:FindFirstChild('Grab') then
                local sword_animation_type = object:FindFirstChild('Grab') and 'Grab' or 'GrabParry'
                Parry_Animation = object[sword_animation_type]
            end
        end
    end

    Grab_Parry = LocalPlayer.Character.Humanoid.Animator:LoadAnimation(Parry_Animation)
    Grab_Parry:Play()
end

function Auto_Parry.Play_Animation(v)
    local Animations = Animation.storage[v]
    if not Animations then
        return false
    end
    local Animator = LocalPlayer.Character.Humanoid.Animator
    if Animation.track then
        Animation.track:Stop()
    end
    Animation.track = Animator:LoadAnimation(Animations)
    Animation.track:Play()
    Animation.current = v
end

function Auto_Parry.Get_Balls()
    local Balls = {}
    for _, Instance in pairs(Workspace.Balls:GetChildren()) do
        if Instance:GetAttribute('realBall') then
            Instance.CanCollide = false
            table.insert(Balls, Instance)
        end
    end
    return Balls
end

function Auto_Parry.Get_Ball()
    for _, Instance in pairs(Workspace.Balls:GetChildren()) do
        if Instance:GetAttribute('realBall') then
            Instance.CanCollide = false
            return Instance
        end
    end
end

function Auto_Parry.Lobby_Balls()
    for _, Instance in pairs(Workspace.TrainingBalls:GetChildren()) do
        if Instance:GetAttribute("realBall") then
            return Instance
        end
    end
end

local Closest_Entity = nil

function Auto_Parry.Closest_Player()
    local Max_Distance = math.huge
    local Found_Entity = nil
    for _, Entity in pairs(Workspace.Alive:GetChildren()) do
        if tostring(Entity) ~= tostring(LocalPlayer) then
            if Entity.PrimaryPart then
                local Distance = LocalPlayer:DistanceFromCharacter(Entity.PrimaryPart.Position)
                if Distance < Max_Distance then
                    Max_Distance = Distance
                    Found_Entity = Entity
                end
            end
        end
    end
    Closest_Entity = Found_Entity
    return Found_Entity
end

function Auto_Parry:Get_Entity_Properties()
    Auto_Parry.Closest_Player()
    if not Closest_Entity then
        return false
    end
    local Entity_Velocity = Closest_Entity.PrimaryPart.Velocity
    local Entity_Direction = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Unit
    local Entity_Distance = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Magnitude
    return {
        Velocity = Entity_Velocity,
        Direction = Entity_Direction,
        Distance = Entity_Distance
    }
end

function Auto_Parry.Parry_Data(Parry_Type)
    Auto_Parry.Closest_Player()
    local Events = {}
    local Camera = Workspace.CurrentCamera
    local Vector2_Mouse_Location
    if Last_Input == Enum.UserInputType.MouseButton1 or Last_Input == Enum.UserInputType.MouseButton2 or Last_Input == Enum.UserInputType.Keyboard then
        local Mouse_Location = UserInputService:GetMouseLocation()
        Vector2_Mouse_Location = {Mouse_Location.X, Mouse_Location.Y}
    else
        Vector2_Mouse_Location = {Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2}
    end
    if isMobile then
        Vector2_Mouse_Location = {Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2}
    end
    local Players_Screen_Positions = {}
    for _, v in pairs(Workspace.Alive:GetChildren()) do
        if v ~= LocalPlayer.Character then
            local worldPos = v.PrimaryPart.Position
            local screenPos, isOnScreen = Camera:WorldToScreenPoint(worldPos)
            if isOnScreen then
                Players_Screen_Positions[v] = Vector2.new(screenPos.X, screenPos.Y)
            end
            Events[tostring(v)] = screenPos
        end
    end
    if Parry_Type == 'Camera' then
        return {0, Camera.CFrame, Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Backwards' then
        local Backwards_Direction = Camera.CFrame.LookVector * -10000
        Backwards_Direction = Vector3.new(Backwards_Direction.X, 0, Backwards_Direction.Z)
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + Backwards_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Straight' then
        local Aimed_Player = nil
        local Closest_Distance = math.huge
        local Mouse_Vector = Vector2.new(Vector2_Mouse_Location[1], Vector2_Mouse_Location[2])
        for _, v in pairs(Workspace.Alive:GetChildren()) do
            if v ~= LocalPlayer.Character then
                local worldPos = v.PrimaryPart.Position
                local screenPos, isOnScreen = Camera:WorldToScreenPoint(worldPos)
                if isOnScreen then
                    local playerScreenPos = Vector2.new(screenPos.X, screenPos.Y)
                    local distance = (Mouse_Vector - playerScreenPos).Magnitude
                    if distance < Closest_Distance then
                        Closest_Distance = distance
                        Aimed_Player = v
                    end
                end
            end
        end
        if Aimed_Player then
            return {0, CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Aimed_Player.PrimaryPart.Position), Events, Vector2_Mouse_Location}
        else
            return {0, CFrame.new(LocalPlayer.Character.PrimaryPart.Position, Closest_Entity and Closest_Entity.PrimaryPart.Position or LocalPlayer.Character.PrimaryPart.Position), Events, Vector2_Mouse_Location}
        end
    elseif Parry_Type == 'Random' then
        return {0, CFrame.new(Camera.CFrame.Position, Vector3.new(math.random(-4000, 4000), math.random(-4000, 4000), math.random(-4000, 4000))), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'High' then
        local High_Direction = Camera.CFrame.UpVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + High_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Left' then
        local Left_Direction = Camera.CFrame.RightVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - Left_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'Right' then
        local Right_Direction = Camera.CFrame.RightVector * 10000
        return {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + Right_Direction), Events, Vector2_Mouse_Location}
    elseif Parry_Type == 'RandomTarget' then
        local candidates = {}
        for _, v in pairs(Workspace.Alive:GetChildren()) do
            if v ~= LocalPlayer.Character and v.PrimaryPart then
                local screenPos, isOnScreen = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
                if isOnScreen then
                    table.insert(candidates, {
                        character = v,
                        screenXY = { screenPos.X, screenPos.Y }
                    })
                end
            end
        end
        if #candidates > 0 then
            local pick = candidates[math.random(1, #candidates)]
            local lookCFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, pick.character.PrimaryPart.Position)
            return {0, lookCFrame, Events, pick.screenXY}
        else
            return {0, Camera.CFrame, Events, { Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2 }}
        end
    end
    return Parry_Type
end

function Auto_Parry.Parry(parryType)
    if not Parry_Remote then
        warn("[Auto_Parry.Parry] Parry_Remote is nil, cannot parry")
        return false
    end

    local Parry_Data = Auto_Parry.Parry_Data(parryType or Selected_Parry_Type)
    if not Parry_Data then
        warn("[Auto_Parry.Parry] Failed to get Parry_Data")
        return false
    end

    local Hash
    if type(Parry_Arg) == "string" and string.match(Parry_Arg, "PARRY_HASH_FAKE") then
        Hash = nil
    else
        Hash = Parry_Arg
    end

    local success, err = pcall(function()
        Parry_Remote:FireServer(Hash, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
    end)
    if not success then
        warn("[Auto_Parry.Parry] Failed to fire remote:", err)
        return false
    end

    if not firstParryFired then
        performFirstPress(firstParryType)
        firstParryFired = true
    end

    if Parries > 7 then
        return false
    end

    Parries = Parries + 1
    task.delay(0.55, function()
        if Parries > 0 then
            Parries = Parries - 1
        end
    end)

    return true
end

function Auto_Parry.Linear_Interpolation(a, b, time_volume)
    return a + (b - a) * time_volume
end

function Auto_Parry.Is_Curved()
    local Ball = Auto_Parry.Get_Ball()
    if not Ball then
        return false
    end
    local Zoomies = Ball:FindFirstChild('zoomies')
    if not Zoomies then
        return false
    end
    local Velocity = Zoomies.VectorVelocity
    local Ball_Direction = Velocity.Unit
    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
    local Dot = Direction:Dot(Ball_Direction)
    local Speed = Velocity.Magnitude
    local Speed_Threshold = math.min(Speed / 100, 40)
    local Direction_Difference = (Ball_Direction - Velocity).Unit
    local Direction_Similarity = Direction:Dot(Direction_Difference)
    local Dot_Difference = Dot - Direction_Similarity
    local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
    local Pings = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
    local Dot_Threshold = 0.5 - (Pings / 1000)
    local Reach_Time = Distance / Speed - (Pings / 1000)
    local Ball_Distance_Threshold = 15 - math.min(Distance / 1000, 15) + Speed_Threshold
    local Clamped_Dot = math.clamp(Dot, -1, 1)
    local Radians = math.rad(math.asin(Clamped_Dot))
    Lerp_Radians = Auto_Parry.Linear_Interpolation(Lerp_Radians, Radians, 0.8)
    if Speed > 100 and Reach_Time > Pings / 10 then
        Ball_Distance_Threshold = math.max(Ball_Distance_Threshold - 15, 15)
    end
    if Distance < Ball_Distance_Threshold then
        return false
    end
    if Dot_Difference < Dot_Threshold then
        return true
    end
    if Lerp_Radians < 0.018 then
        Last_Warping = tick()
    end
    if (tick() - Last_Warping) < (Reach_Time / 1.5) then
        return true
    end
    if (tick() - Curving) < (Reach_Time / 1.5) then
        return true
    end
    return Dot < Dot_Threshold
end

function Auto_Parry:Get_Ball_Properties()
    local Ball = Auto_Parry.Get_Ball()
    local Ball_Velocity = Vector3.zero
    local Ball_Origin = Ball
    local Ball_Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball_Origin.Position).Unit
    local Ball_Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
    local Ball_Dot = Ball_Direction:Dot(Ball_Velocity.Unit)
    return {
        Velocity = Ball_Velocity,
        Direction = Ball_Direction,
        Distance = Ball_Distance,
        Dot = Ball_Dot
    }
end

function Auto_Parry.Spam_Service(self)
    local Ball = Auto_Parry.Get_Ball()
    local Entity = Auto_Parry.Closest_Player()
    if not Ball or not Entity or not Entity.PrimaryPart then
        return false
    end
    local Spam_Accuracy = 0
    local Velocity = Ball.AssemblyLinearVelocity
    local Speed = Velocity.Magnitude
    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
    local Dot = Direction:Dot(Velocity.Unit)
    local Target_Position = Entity.PrimaryPart.Position
    local Target_Distance = LocalPlayer:DistanceFromCharacter(Target_Position)
    local Maximum_Spam_Distance = self.Ping + math.min(Speed / 6, 95)
    if self.Entity_Properties.Distance > Maximum_Spam_Distance or self.Ball_Properties.Distance > Maximum_Spam_Distance or Target_Distance > Maximum_Spam_Distance then
        return Spam_Accuracy
    end
    local Maximum_Speed = 5 - math.min(Speed / 5, 5)
    local Maximum_Dot = math.clamp(Dot, -1, 0) * Maximum_Speed
    Spam_Accuracy = Maximum_Spam_Distance - Maximum_Dot
    return Spam_Accuracy
end

local function GetBall()
    for _, Ball in ipairs(Balls:GetChildren()) do
        if Ball:FindFirstChild("ff") then
            return Ball
        end
    end
    return nil
end

local function isCooldownInEffect1(uigradient)
    return uigradient.Offset.Y < 0.4
end

local function isCooldownInEffect2(uigradient)
    return uigradient.Offset.Y == 0.5
end

local function cooldownProtection()
    if isCooldownInEffect1(ParryCD) then
        ReplicatedStorage.Remotes.AbilityButtonPress:Fire()
        return true
    end
    return false
end

local function AutoAbility()
    if isCooldownInEffect2(AbilityCD) then
        if LocalPlayer.Character.Abilities["Raging Deflection"].Enabled or LocalPlayer.Character.Abilities["Rapture"].Enabled or LocalPlayer.Character.Abilities["Calming Deflection"].Enabled or LocalPlayer.Character.Abilities["Aerodynamic Slash"].Enabled or LocalPlayer.Character.Abilities["Fracture"].Enabled or LocalPlayer.Character.Abilities["Death Slash"].Enabled then
            Parried = true
            ReplicatedStorage.Remotes.AbilityButtonPress:Fire()
            task.wait(2.432)
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("DeathSlashShootActivation"):FireServer(true)
            return true
        end
    end
    return false
end

-- New Functions for Additions
local function applySkyColor(color)
    Lighting.Ambient = color
    Lighting.OutdoorAmbient = color
    if skyColorConnection then
        skyColorConnection:Disconnect()
    end
    skyColorConnection = RunService.Heartbeat:Connect(function()
        Lighting.Ambient = color
        Lighting.OutdoorAmbient = color
    end)
end

local function applySkybox(skyboxType)
    if currentSkybox then
        currentSkybox:Destroy()
    end
    local sky = Instance.new("Sky")
    sky.Parent = Lighting
    currentSkybox = sky
    if skyboxType == "Midnight" then
        sky.SkyboxBk = "rbxassetid://159067838"
        sky.SkyboxDn = "rbxassetid://159067846"
        sky.SkyboxFt = "rbxassetid://159067853"
        sky.SkyboxLf = "rbxassetid://159067860"
        sky.SkyboxRt = "rbxassetid://159067868"
        sky.SkyboxUp = "rbxassetid://159067875"
    elseif skyboxType == "Space" then
        sky.SkyboxBk = "rbxassetid://159248189"
        sky.SkyboxDn = "rbxassetid://159248192"
        sky.SkyboxFt = "rbxassetid://159248194"
        sky.SkyboxLf = "rbxassetid://159248196"
        sky.SkyboxRt = "rbxassetid://159248198"
        sky.SkyboxUp = "rbxassetid://159248200"
    elseif skyboxType == "Galaxy" then
        sky.SkyboxBk = "rbxassetid://183778618"
        sky.SkyboxDn = "rbxassetid://183778625"
        sky.SkyboxFt = "rbxassetid://183778630"
        sky.SkyboxLf = "rbxassetid://183778635"
        sky.SkyboxRt = "rbxassetid://183778641"
        sky.SkyboxUp = "rbxassetid://183778647"
    elseif skyboxType == "Christmas" then
        sky.SkyboxBk = "rbxassetid://383212508"
        sky.SkyboxDn = "rbxassetid://383212513"
        sky.SkyboxFt = "rbxassetid://383212518"
        sky.SkyboxLf = "rbxassetid://383212523"
        sky.SkyboxRt = "rbxassetid://383212528"
        sky.SkyboxUp = "rbxassetid://383212533"
    end
end

local function applyShader(shaderType)
    if currentShader then
        currentShader:Destroy()
    end
    local colorCorrection = Instance.new("ColorCorrectionEffect")
    colorCorrection.Parent = Lighting
    currentShader = colorCorrection
    if shaderType == "Mid Purple Day" then
        colorCorrection.TintColor = Color3.fromRGB(200, 150, 255)
        colorCorrection.Brightness = 0.1
        colorCorrection.Contrast = 0.1
        colorCorrection.Saturation = 0.2
    elseif shaderType == "Mid Pink Day" then
        colorCorrection.TintColor = Color3.fromRGB(255, 150, 200)
        colorCorrection.Brightness = 0.1
        colorCorrection.Contrast = 0.1
        colorCorrection.Saturation = 0.2
    elseif shaderType == "Mid Day" then
        colorCorrection.TintColor = Color3.fromRGB(255, 255, 255)
        colorCorrection.Brightness = 0.15
        colorCorrection.Contrast = 0.1
        colorCorrection.Saturation = 0.1
    elseif shaderType == "Evening" then
        colorCorrection.TintColor = Color3.fromRGB(255, 200, 150)
        colorCorrection.Brightness = 0.05
        colorCorrection.Contrast = 0.1
        colorCorrection.Saturation = 0.15
    elseif shaderType == "Night" then
        colorCorrection.TintColor = Color3.fromRGB(100, 100, 200)
        colorCorrection.Brightness = -0.1
        colorCorrection.Contrast = 0.1
        colorCorrection.Saturation = 0.1
    end
end

local function playMusic(musicId)
    if musicPlayer then
        musicPlayer:Destroy()
    end
    if musicId == "" then
        return
    end
    musicPlayer = Instance.new("Sound")
    musicPlayer.SoundId = "rbxassetid://" .. musicId
    musicPlayer.Parent = LocalPlayer.Character
    musicPlayer:Play()
end

local function pauseMusic()
    if musicPlayer then
        musicPlayer:Pause()
    end
end

local function pauseBall()
    local Ball = Auto_Parry.Get_Ball()
    if not Ball or not BallPauseEnabled then return end
    local Zoomies = Ball:FindFirstChild('zoomies')
    if not Zoomies then return end
    local Ball_Target = Ball:GetAttribute('target')
    if Ball_Target ~= tostring(LocalPlayer) then return end
    local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
    local Velocity = Zoomies.VectorVelocity
    local Speed = Velocity.Magnitude
    local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue() / 1000
    local Reach_Time = Distance / Speed - Ping
    if Distance <= BallPauseDistanceThreshold and Reach_Time < 0.1 then
        ReplicatedStorage.Remotes.InfinityBall:FireServer(true)
        task.wait(0.1)
        ReplicatedStorage.Remotes.InfinityBall:FireServer(false)
    end
end

-- UI Setup with Tabs
local BlatantTab = Window:CreateTab("Blatant")
local PlayerTab = Window:CreateTab("Player")
local VisualsTab = Window:CreateTab("Visuals")
local MiscTab = Window:CreateTab("Misc")
local CreditsTab = Window:CreateTab("Credits")
local UtilityTab = Window:CreateTab("Utility") -- New tab for additional features
local CombatTab = Window:CreateTab("Combat")   -- New tab for combat enhancements

-- Credits Tab
local CreditsMainSection = CreditsTab:CreateSection("Main Credits")
CreditsTab:CreateLabel("Original Script: Kryp Paid Team")
CreditsTab:CreateLabel("UI Conversion: Shaman Team")

local CreditsUISection = CreditsTab:CreateSection("UI Credits")
CreditsTab:CreateLabel("Rain-Design: Shaman UI Library")

local CreditsHelpSection = CreditsTab:CreateSection("Helping Credits")
CreditsTab:CreateLabel("Community: Testing & Feedback")

-- Blatant Tab
local AutoParrySection = BlatantTab:CreateSection("Auto Parry")
BlatantTab:CreateLabel("Welcome, "..LocalPlayer.DisplayName.." to Kryp Paid!")

BlatantTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      if value then
         Connections_Manager['Auto Parry'] = RunService.PreSimulation:Connect(function()
            local One_Ball = Auto_Parry.Get_Ball()
            local Balls = Auto_Parry.Get_Balls()
            for _, Ball in pairs(Balls) do
               if not Ball then return end
               local Zoomies = Ball:FindFirstChild('zoomies')
               if not Zoomies then return end
               Ball:GetAttributeChangedSignal('target'):Once(function()
                  Parried = false
               end)
               if Parried then return end
               local Ball_Target = Ball:GetAttribute('target')
               local One_Target = One_Ball:GetAttribute('target')
               local Velocity = Zoomies.VectorVelocity
               local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
               local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue() / 10
               local Ping_Threshold = math.clamp(Ping / 10, 5, 17)
               local Speed = Velocity.Magnitude
               local cappedSpeedDiff = math.min(math.max(Speed - 9.5, 0), 650)
               local speed_divisor_base = 2.4 + cappedSpeedDiff * 0.002
               local effectiveMultiplier = Speed_Divisor_Multiplier
               if Flags.RandomParryAccuracy then
                  if Speed < 200 then
                     effectiveMultiplier = 0.7 + (math.random(40, 100) - 1) * (0.35 / 99)
                  else
                     effectiveMultiplier = 0.7 + (math.random(1, 100) - 1) * (0.35 / 99)
                  end
               end
               local speed_divisor = speed_divisor_base * effectiveMultiplier
               local Parry_Accuracy = Ping_Threshold + math.max(Speed / speed_divisor, 9.5)
               local Curved = Auto_Parry.Is_Curved()
               if Phantom and LocalPlayer.Character:FindFirstChild('ParryHighlight') and Flags.PhantomDetection then
                  ContextActionService:BindAction('BlockPlayerMovement', BlockMovement, false, Enum.KeyCode.W, Enum.KeyCode.A, Enum.KeyCode.S, Enum.KeyCode.D, Enum.UserInputType.Touch)
                  LocalPlayer.Character.Humanoid.WalkSpeed = 36
                  LocalPlayer.Character.Humanoid:MoveTo(Ball.Position)
                  task.spawn(function()
                     repeat
                        if LocalPlayer.Character.Humanoid.WalkSpeed ~= 36 then
                           LocalPlayer.Character.Humanoid.WalkSpeed = 36
                        end
                        task.wait()
                     until not Phantom
                  end)
                  Ball:GetAttributeChangedSignal('target'):Once(function()
                     ContextActionService:UnbindAction('BlockPlayerMovement')
                     Phantom = false
                     LocalPlayer.Character.Humanoid:MoveTo(LocalPlayer.Character.HumanoidRootPart.Position)
                     LocalPlayer.Character.Humanoid.WalkSpeed = 10
                     task.delay(3, function()
                        LocalPlayer.Character.Humanoid.WalkSpeed = 36
                     end)
                  end)
               end
               if Ball_Target == tostring(LocalPlayer) and Distance <= Parry_Accuracy and Phantom then
                  VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
                  VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
                  Parried = true
               end
               if Ball:FindFirstChild('AeroDynamicSlashVFX') then
                  Debris:AddItem(Ball.AeroDynamicSlashVFX, 0)
                  Tornado_Time = tick()
               end
               if Runtime:FindFirstChild('Tornado') then
                  if (tick() - Tornado_Time) < (Runtime.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159 then
                     return
                  end
               end
               if One_Target == tostring(LocalPlayer) and Curved then
                  return
               end
               if Ball:FindFirstChild("ComboCounter") then
                  return
               end
               local Singularity_Cape = LocalPlayer.Character.PrimaryPart:FindFirstChild('SingularityCape')
               if Singularity_Cape then
                  return
               end
               if Flags.InfinityDetection and Infinity then
                  return
               end
               if Ball_Target == tostring(LocalPlayer) and Distance <= Parry_Accuracy then
                  if Flags.AutoAbility and AutoAbility() then
                     return
                  end
               end
               if Ball_Target == tostring(LocalPlayer) and Distance <= Parry_Accuracy then
                  if Flags.CooldownProtection and cooldownProtection() then
                     return
                  end
                  local Parry_Time = os.clock()
                  local Time_View = Parry_Time - Last_Parry
                  if Time_View > 0.5 then
                     Auto_Parry.Parry_Animation()
                  end
                  if Flags.AutoParryKeypress then
                     VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, nil)
                  else
                     Auto_Parry.Parry(Selected_Parry_Type)
                  end
                  Last_Parry = Parry_Time
                  Parried = true
               end
               local Last_Parrys = tick()
               repeat
                  RunService.PreSimulation:Wait()
               until (tick() - Last_Parrys) >= 1 or not Parried
               Parried = false
            end
         end)
      else
         if Connections_Manager['Auto Parry'] then
            Connections_Manager['Auto Parry']:Disconnect()
            Connections_Manager['Auto Parry'] = nil
         end
      end
   end
})

BlatantTab:CreateSlider({
   Name = "Parry Accuracy",
   Range = {1, 100},
   Increment = 1,
   Suffix = "%",
   CurrentValue = 100,
   Callback = function(value)
      Speed_Divisor_Multiplier = 0.7 + (value - 1) * (0.35 / 99)
   end
})

local parryTypeMap = {
   ["Camera"] = "Camera",
   ["Random"] = "Random",
   ["Backwards"] = "Backwards",
   ["Straight"] = "Straight",
   ["High"] = "High",
   ["Left"] = "Left",
   ["Right"] = "Right",
   ["Random Target"] = "RandomTarget"
}

BlatantTab:CreateDropdown({
   Name = "Curve Type",
   Options = {"Camera", "Random", "Backwards", "Straight", "High", "Left", "Right", "Random Target"},
   CurrentOption = "Camera",
   Callback = function(value)
      Selected_Parry_Type = parryTypeMap[value] or value
   end
})

BlatantTab:CreateToggle({
   Name = "Random Parry Accuracy",
   CurrentValue = false,
   Callback = function(value)
      Flags.RandomParryAccuracy = value
   end
})

BlatantTab:CreateToggle({
   Name = "Infinity Detection",
   CurrentValue = false,
   Callback = function(value)
      Flags.InfinityDetection = value
   end
})

BlatantTab:CreateToggle({
   Name = "Keypress",
   CurrentValue = false,
   Callback = function(value)
      Flags.AutoParryKeypress = value
   end
})

BlatantTab:CreateToggle({
   Name = "Phantom Detection",
   CurrentValue = false,
   Callback = function(value)
      Flags.PhantomDetection = value
   end
})

BlatantTab:CreateToggle({
   Name = "Auto Ability",
   CurrentValue = false,
   Callback = function(value)
      Flags.AutoAbility = value
   end
})

BlatantTab:CreateToggle({
   Name = "Cooldown Protection",
   CurrentValue = false,
   Callback = function(value)
      Flags.CooldownProtection = value
   end
})

local AutoSpamParrySection = BlatantTab:CreateSection("Auto Spam Parry")
local AutoSpamActive = false

local function toggleAutoSpam(activate)
   AutoSpamActive = activate
   if activate then
      if not Connections_Manager['Auto Spam'] then
         Connections_Manager['Auto Spam'] = RunService.Heartbeat:Connect(function()
            if Flags.SpamParryKeypress then
               VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
               VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
            else
               Auto_Parry.Parry(Selected_Parry_Type)
            end
         end)
      end
   else
      if Connections_Manager['Auto Spam'] then
         Connections_Manager['Auto Spam']:Disconnect()
         Connections_Manager['Auto Spam'] = nil
      end
   end
end

local function checkAutoSpam()
   local Ball = Auto_Parry.Get_Ball()
   if not Ball then
      if AutoSpamActive then
         toggleAutoSpam(false)
      end
      return
   end
   local Zoomies = Ball:FindFirstChild('zoomies')
   if not Zoomies then
      if AutoSpamActive then
         toggleAutoSpam(false)
      end
      return
   end
   Auto_Parry.Closest_Player()
   local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
   local Ping_Threshold = math.clamp(Ping / 10, 1, 16)
   local Ball_Target = Ball:GetAttribute('target')
   local Ball_Properties = Auto_Parry:Get_Ball_Properties()
   local Entity_Properties = Auto_Parry:Get_Entity_Properties()
   local Spam_Accuracy = Auto_Parry.Spam_Service({
      Ball_Properties = Ball_Properties,
      Entity_Properties = Entity_Properties,
      Ping = Ping_Threshold
   })
   local Target_Position = Closest_Entity and Closest_Entity.PrimaryPart.Position
   local Target_Distance = Target_Position and LocalPlayer:DistanceFromCharacter(Target_Position) or math.huge
   local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
   local Ball_Direction = Zoomies.VectorVelocity.Unit
   local Dot = Direction:Dot(Ball_Direction)
   local Distance = LocalPlayer:DistanceFromCharacter(Ball.Position)
   local Pulsed = LocalPlayer.Character:GetAttribute('Pulsed')
   local FastSpamAccuracy = Spam_Accuracy * 0.8
   if Ball_Target and not Pulsed and Target_Distance <= FastSpamAccuracy and Distance <= FastSpamAccuracy and Parries <= ParryThreshold then
      if not AutoSpamActive then
         toggleAutoSpam(true)
      end
   else
      if AutoSpamActive then
         toggleAutoSpam(false)
      end
   end
end

BlatantTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      if value then
         Connections_Manager['Auto Spam Check'] = RunService.Heartbeat:Connect(checkAutoSpam)
      else
         if Connections_Manager['Auto Spam Check'] then
            Connections_Manager['Auto Spam Check']:Disconnect()
            Connections_Manager['Auto Spam Check'] = nil
         end
         if AutoSpamActive then
            toggleAutoSpam(false)
         end
      end
   end
})

BlatantTab:CreateDropdown({
   Name = "Parry Type",
   Options = {"Legit", "Blatant"},
   CurrentOption = "Legit",
   Callback = function(value)
      -- Handle parry type if needed
   end
})

BlatantTab:CreateSlider({
   Name = "Parry Threshold",
   Range = {0, 5},
   Increment = 0.1,
   Suffix = "",
   CurrentValue = 2.5,
   Callback = function(value)
      ParryThreshold = value
   end
})

BlatantTab:CreateToggle({
   Name = "Spam Parry Keypress",
   CurrentValue = false,
   Callback = function(value)
      Flags.SpamParryKeypress = value
   end
})

if not isMobile then
   BlatantTab:CreateToggle({
      Name = "Animation Fix",
      CurrentValue = false,
      Callback = function(value)
         if value then
            Connections_Manager['Animation Fix'] = RunService.PreSimulation:Connect(function()
               local Ball = Auto_Parry.Get_Ball()
               if not Ball then return end
               local Zoomies = Ball:FindFirstChild('zoomies')
               if not Zoomies then return end
               Auto_Parry.Closest_Player()
               local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
               local Ping_Threshold = math.clamp(Ping / 10, 10, 16)
               local Ball_Target = Ball:GetAttribute('target')
               local Ball_Properties = Auto_Parry:Get_Ball_Properties()
               local Entity_Properties = Auto_Parry:Get_Entity_Properties()
               local Spam_Accuracy = Auto_Parry.Spam_Service({
                  Ball_Properties = Ball_Properties,
                  Entity_Properties = Entity_Properties,
                  Ping = Ping_Threshold
               })
               local Target_Position = Closest_Entity and Closest_Entity.PrimaryPart.Position
               local Target_Distance = Target_Position and LocalPlayer:DistanceFromCharacter(Target_Position) or math.huge
               local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
               local Ball_Direction = Zoomies.VectorVelocity.Unit
               local Dot = Direction:Dot(Ball_Direction)
               local Distance = LocalPlayer:DistanceFromCharacter(Ball.Position)
               if not Ball_Target then return end
               if Target_Distance > Spam_Accuracy or Distance > Spam_Accuracy then return end
               local Pulsed = LocalPlayer.Character:GetAttribute('Pulsed')
               if Pulsed then return end
               if Ball_Target == tostring(LocalPlayer) and Target_Distance > 30 and Distance > 30 then
                  return
               end
               local threshold = ParryThreshold
               if Distance <= Spam_Accuracy and Parries > threshold then
                  VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
               end
            end)
         else
            if Connections_Manager['Animation Fix'] then
               Connections_Manager['Animation Fix']:Disconnect()
               Connections_Manager['Animation Fix'] = nil
            end
         end
      end
   })
end

local ManualSpamSection = BlatantTab:CreateSection("Manual Spam")
local AutoManualSpamEnabled = false
local ManualSpamActive = false

local function toggleManualSpam(activate)
   ManualSpamActive = activate
   local button = CoreGui:FindFirstChild("ManualSpamUI") and CoreGui.ManualSpamUI.MainFrame.ClashModeButton
   if button then
      if AutoManualSpamEnabled and not ManualSpamActive then
         button.Text = "Auto"
         button.TextColor3 = Color3.new(0, 0, 1)
      else
         button.Text = activate and "Stop" or "Clash Mode"
         button.TextColor3 = activate and Color3.new(0, 1, 0) or Color3.new(1, 0, 0)
      end
   end
   if activate then
      if not Connections_Manager['Manual Spam'] then
         Connections_Manager['Manual Spam'] = RunService.Heartbeat:Connect(function()
            Auto_Parry.Parry(Selected_Parry_Type)
         end)
      end
   else
      if Connections_Manager['Manual Spam'] then
         Connections_Manager['Manual Spam']:Disconnect()
         Connections_Manager['Manual Spam'] = nil
      end
   end
end

local function checkAutoManualSpam()
   if not AutoManualSpamEnabled then return end
   local Ball = Auto_Parry.Get_Ball()
   if not Ball then
      if ManualSpamActive then
         toggleManualSpam(false)
      end
      return
   end
   local Zoomies = Ball:FindFirstChild('zoomies')
   if not Zoomies then
      if ManualSpamActive then
         toggleManualSpam(false)
      end
      return
   end
   Auto_Parry.Closest_Player()
   local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
   local Ping_Threshold = math.clamp(Ping / 10, 1, 16)
   local Ball_Target = Ball:GetAttribute('target')
   local Ball_Properties = Auto_Parry:Get_Ball_Properties()
   local Entity_Properties = Auto_Parry:Get_Entity_Properties()
   local Spam_Accuracy = Auto_Parry.Spam_Service({
      Ball_Properties = Ball_Properties,
      Entity_Properties = Entity_Properties,
      Ping = Ping_Threshold
   })
   local Target_Position = Closest_Entity and Closest_Entity.PrimaryPart.Position
   local Target_Distance = Target_Position and LocalPlayer:DistanceFromCharacter(Target_Position) or math.huge
   local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
   local Ball_Direction = Zoomies.VectorVelocity.Unit
   local Dot = Direction:Dot(Ball_Direction)
   local Distance = LocalPlayer:DistanceFromCharacter(Ball.Position)
   local Pulsed = LocalPlayer.Character:GetAttribute('Pulsed')
   local FastSpamAccuracy = Spam_Accuracy * 0.8
   if Ball_Target and not Pulsed and Target_Distance <= FastSpamAccuracy and Distance <= FastSpamAccuracy and Parries <= ParryThreshold then
      if not ManualSpamActive then
         toggleManualSpam(true)
      end
   else
      if ManualSpamActive then
         toggleManualSpam(false)
      end
   end
end

BlatantTab:CreateButton({
   Name = "Toggle Automatically",
   Callback = function()
      AutoManualSpamEnabled = not AutoManualSpamEnabled
      if AutoManualSpamEnabled then
         Connections_Manager['Auto Manual Spam'] = RunService.Heartbeat:Connect(checkAutoManualSpam)
         local button = CoreGui:FindFirstChild("ManualSpamUI") and CoreGui.ManualSpamUI.MainFrame.ClashModeButton
         if button and not ManualSpamActive then
            button.Text = "Auto"
            button.TextColor3 = Color3.new(0, 0, 1)
         end
      else
         if Connections_Manager['Auto Manual Spam'] then
            Connections_Manager['Auto Manual Spam']:Disconnect()
            Connections_Manager['Auto Manual Spam'] = nil
         end
         if ManualSpamActive then
            toggleManualSpam(false)
         end
         local button = CoreGui:FindFirstChild("ManualSpamUI") and CoreGui.ManualSpamUI.MainFrame.ClashModeButton
         if button then
            button.Text = "Clash Mode"
            button.TextColor3 = Color3.new(1, 0, 0)
         end
      end
   end
})

BlatantTab:CreateToggle({
   Name = "Manual Spam UI",
   CurrentValue = false,
   Callback = function(value)
      if value then
         if not CoreGui:FindFirstChild("ManualSpamUI") then
            local gui = Instance.new("ScreenGui")
            gui.Name = "ManualSpamUI"
            gui.ResetOnSpawn = false
            gui.Parent = CoreGui

            local frame = Instance.new("Frame")
            frame.Name = "MainFrame"
            frame.Position = UDim2.new(0, 20, 0, 20)
            frame.Size = UDim2.new(0, 160, 0, 60)
            frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            frame.BackgroundTransparency = 0.3
            frame.BorderSizePixel = 0
            frame.Active = true
            frame.Draggable = true
            frame.Parent = gui

            local uiCorner = Instance.new("UICorner")
            uiCorner.CornerRadius = UDim.new(0, 12)
            uiCorner.Parent = frame

            local uiStroke = Instance.new("UIStroke")
            uiStroke.Thickness = 2
            uiStroke.Color = Color3.new(0, 0, 0)
            uiStroke.Parent = frame

            local button = Instance.new("TextButton")
            button.Name = "ClashModeButton"
            button.Text = AutoManualSpamEnabled and "Auto" or "Clash Mode"
            button.TextColor3 = AutoManualSpamEnabled and Color3.new(0, 0, 1) or Color3.new(1, 0, 0)
            button.Size = UDim2.new(0, 120, 0, 40)
            button.Position = UDim2.new(0.5, -60, 0.5, -20)
            button.BackgroundTransparency = 1
            button.BorderSizePixel = 0
            button.Font = Enum.Font.GothamSemibold
            button.TextSize = 18
            button.Parent = frame

            Connections_Manager['Manual Spam Keybind'] = UserInputService.InputBegan:Connect(function(input, gameProcessed)
               if gameProcessed then return end
               if input.KeyCode == Enum.KeyCode.E then
                  if not AutoManualSpamEnabled then
                     toggleManualSpam(not ManualSpamActive)
                  end
               end
            end)
         end
      else
         if CoreGui:FindFirstChild("ManualSpamUI") then
            CoreGui:FindFirstChild("ManualSpamUI"):Destroy()
         end
         if Connections_Manager['Manual Spam'] then
            Connections_Manager['Manual Spam']:Disconnect()
            Connections_Manager['Manual Spam'] = nil
         end
         if Connections_Manager['Auto Manual Spam'] then
            Connections_Manager['Auto Manual Spam']:Disconnect()
            Connections_Manager['Auto Manual Spam'] = nil
         end
         if Connections_Manager['Manual Spam Keybind'] then
            Connections_Manager['Manual Spam Keybind']:Disconnect()
            Connections_Manager['Manual Spam Keybind'] = nil
         end
         ManualSpamActive = false
         AutoManualSpamEnabled = false
      end
   end
})

local BallPauseSection = BlatantTab:CreateSection("Ball Pause")
BlatantTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      BallPauseEnabled = value
      if value then
         Connections_Manager['Ball Pause'] = RunService.Heartbeat:Connect(pauseBall)
      else
         if Connections_Manager['Ball Pause'] then
            Connections_Manager['Ball Pause']:Disconnect()
            Connections_Manager['Ball Pause'] = nil
         end
      end
   end
})

local LobbyAPSection = BlatantTab:CreateSection("Lobby Auto Parry")
BlatantTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      if value then
         Connections_Manager['Lobby AP'] = RunService.Heartbeat:Connect(function()
            local Ball = Auto_Parry.Lobby_Balls()
            if not Ball then return end
            local Zoomies = Ball:FindFirstChild('zoomies')
            if not Zoomies then return end
            Ball:GetAttributeChangedSignal('target'):Once(function()
               Training_Parried = false
            end)
            if Training_Parried then return end
            local Ball_Target = Ball:GetAttribute('target')
            local Velocity = Zoomies.VectorVelocity
            local Distance = LocalPlayer:DistanceFromCharacter(Ball.Position)
            local Speed = Velocity.Magnitude
            local Ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue() / 10
            local LobbyAPcappedSpeedDiff = math.min(math.max(Speed - 9.5, 0), 650)
            local LobbyAPspeed_divisor_base = 2.4 + LobbyAPcappedSpeedDiff * 0.002
            local LobbyAPeffectiveMultiplier = LobbyAP_Speed_Divisor_Multiplier
            if Flags.LobbyAPRandomParryAccuracy then
               LobbyAPeffectiveMultiplier = 0.7 + (math.random(1, 100) - 1) * (0.35 / 99)
            end
            local LobbyAPspeed_divisor = LobbyAPspeed_divisor_base * LobbyAPeffectiveMultiplier
            local LobbyAPParry_Accuracys = Ping + math.max(Speed / LobbyAPspeed_divisor, 9.5)
            if Ball_Target == tostring(LocalPlayer) and Distance <= LobbyAPParry_Accuracys then
               if Flags.LobbyAPKeypress then
                  VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
               else
                  Auto_Parry.Parry(Selected_Parry_Type)
               end
               Training_Parried = true
            end
            local Last_Parrys = tick()
            repeat
               RunService.PreSimulation:Wait()
            until (tick() - Last_Parrys) >= 1 or not Training_Parried
            Training_Parried = false
         end)
      else
         if Connections_Manager['Lobby AP'] then
            Connections_Manager['Lobby AP']:Disconnect()
            Connections_Manager['Lobby AP'] = nil
         end
      end
   end
})

BlatantTab:CreateSlider({
   Name = "Parry Accuracy",
   Range = {1, 100},
   Increment = 1,
   Suffix = "%",
   CurrentValue = 100,
   Callback = function(value)
      LobbyAP_Speed_Divisor_Multiplier = 0.7 + (value - 1) * (0.35 / 99)
   end
})

BlatantTab:CreateToggle({
   Name = "Random Parry Accuracy",
   CurrentValue = false,
   Callback = function(value)
      Flags.LobbyAPRandomParryAccuracy = value
   end
})

BlatantTab:CreateToggle({
   Name = "Keypress",
   CurrentValue = false,
   Callback = function(value)
      Flags.LobbyAPKeypress = value
   end
})

-- Player Tab
local SpeedSection = PlayerTab:CreateSection("Speed")
PlayerTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      if value then
         Connections_Manager['Strafe'] = RunService.PreSimulation:Connect(function()
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("Humanoid") then
               character.Humanoid.WalkSpeed = StrafeSpeed
            end
         end)
      else
         local character = LocalPlayer.Character
         if character and character:FindFirstChild("Humanoid") then
            character.Humanoid.WalkSpeed = 36
         end
         if Connections_Manager['Strafe'] then
            Connections_Manager['Strafe']:Disconnect()
            Connections_Manager['Strafe'] = nil
         end
      end
   end
})

PlayerTab:CreateSlider({
   Name = "Speed",
   Range = {36, 200},
   Increment = 1,
   Suffix = " studs/sec",
   CurrentValue = 36,
   Callback = function(value)
      StrafeSpeed = value
   end
})

local SpinbotSection = PlayerTab:CreateSection("Spinbot")
PlayerTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      getgenv().spin = value
      if value then
         getgenv().spinSpeed = getgenv().spinSpeed or 1
         if not getgenv().spinThread then
            getgenv().spinThread = coroutine.create(function()
               while getgenv().spin do
                  RunService.Heartbeat:Wait()
                  local char = LocalPlayer.Character
                  local funcHRP = char and char:FindFirstChild("HumanoidRootPart")
                  if char and funcHRP then
                     funcHRP.CFrame *= CFrame.Angles(0, getgenv().spinSpeed, 0)
                  end
               end
            end)
            coroutine.resume(getgenv().spinThread)
         end
      else
         if getgenv().spinThread then
            getgenv().spinThread = nil
         end
      end
   end
})

PlayerTab:CreateSlider({
   Name = "Speed",
   Range = {1, 100},
   Increment = 1,
   Suffix = " deg/sec",
   CurrentValue = 1,
   Callback = function(value)
      getgenv().spinSpeed = math.rad(value)
   end
})

local FieldOfViewSection = PlayerTab:CreateSection("Field of View")
PlayerTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      if value then
         getgenv().CameraFOV = getgenv().CameraFOV or 70
         Workspace.CurrentCamera.FieldOfView = getgenv().CameraFOV
         if not getgenv().FOVLoop then
            getgenv().FOVLoop = RunService.RenderStepped:Connect(function()
               if value then
                  Workspace.CurrentCamera.FieldOfView = getgenv().CameraFOV
               end
            end)
         end
      else
         Workspace.CurrentCamera.FieldOfView = 70
         if getgenv().FOVLoop then
            getgenv().FOVLoop:Disconnect()
            getgenv().FOVLoop = nil
         end
      end
   end
})

PlayerTab:CreateSlider({
   Name = "FOV",
   Range = {50, 150},
   Increment = 1,
   Suffix = " degrees",
   CurrentValue = 70,
   Callback = function(value)
      getgenv().CameraFOV = value
      if Workspace.CurrentCamera.FieldOfView ~= value then
         Workspace.CurrentCamera.FieldOfView = value
      end
   end
})

local PlayerCosmeticsSection = PlayerTab:CreateSection("Player Cosmetics")
_G.PlayerCosmeticsCleanup = {}

PlayerTab:CreateToggle({
   Name = "Korblox/Headless",
   CurrentValue = false,
   Callback = function(value)
      local function applyKorblox(character)
         local rightLeg = character:FindFirstChild("RightLeg") or character:FindFirstChild("Right Leg")
         if not rightLeg then return end
         for _, child in pairs(rightLeg:GetChildren()) do
            if child:IsA("SpecialMesh") then
               child:Destroy()
            end
         end
         local specialMesh = Instance.new("SpecialMesh")
         specialMesh.MeshId = "rbxassetid://101851696"
         specialMesh.TextureId = "rbxassetid://115727863"
         specialMesh.Scale = Vector3.new(1, 1, 1)
         specialMesh.Parent = rightLeg
      end
      local function saveRightLegProperties(char)
         if char then
            local rightLeg = char:FindFirstChild("RightLeg") or char:FindFirstChild("Right Leg")
            if rightLeg then
               local originalMesh = rightLeg:FindFirstChildOfClass("SpecialMesh")
               if originalMesh then
                  _G.PlayerCosmeticsCleanup.originalMeshId = originalMesh.MeshId
                  _G.PlayerCosmeticsCleanup.originalTextureId = originalMesh.TextureId
                  _G.PlayerCosmeticsCleanup.originalScale = originalMesh.Scale
               else
                  _G.PlayerCosmeticsCleanup.hadNoMesh = true
               end
               _G.PlayerCosmeticsCleanup.rightLegChildren = {}
               for _, child in pairs(rightLeg:GetChildren()) do
                  if child:IsA("SpecialMesh") then
                     table.insert(_G.PlayerCosmeticsCleanup.rightLegChildren, {
                        ClassName = child.ClassName,
                        Properties = {
                           MeshId = child.MeshId,
                           TextureId = child.TextureId,
                           Scale = child.Scale
                        }
                     })
                  end
               end
            end
         end
      end
      local function restoreRightLeg(char)
         if char then
            local rightLeg = char:FindFirstChild("RightLeg") or char:FindFirstChild("Right Leg")
            if rightLeg and _G.PlayerCosmeticsCleanup.rightLegChildren then
               for _, child in pairs(rightLeg:GetChildren()) do
                  if child:IsA("SpecialMesh") then
                     child:Destroy()
                  end
               end
               if _G.PlayerCosmeticsCleanup.hadNoMesh then
                  return
               end
               for _, childData in ipairs(_G.PlayerCosmeticsCleanup.rightLegChildren) do
                  if childData.ClassName == "SpecialMesh" then
                     local newMesh = Instance.new("SpecialMesh")
                     newMesh.MeshId = childData.Properties.MeshId
                     newMesh.TextureId = childData.Properties.TextureId
                     newMesh.Scale = childData.Properties.Scale
                     newMesh.Parent = rightLeg
                  end
               end
            end
         end
      end
      if value then
         CosmeticsActive = true
         getgenv().Config = { Headless = true }
         if LocalPlayer.Character then
            local head = LocalPlayer.Character:FindFirstChild("Head")
            if head and getgenv().Config.Headless then
               _G.PlayerCosmeticsCleanup.headTransparency = head.Transparency
               local decal = head:FindFirstChildOfClass("Decal")
               if decal then
                  _G.PlayerCosmeticsCleanup.faceDecalId = decal.Texture
                  _G.PlayerCosmeticsCleanup.faceDecalName = decal.Name
               end
            end
            saveRightLegProperties(LocalPlayer.Character)
            applyKorblox(LocalPlayer.Character)
         end
         _G.PlayerCosmeticsCleanup.characterAddedConn = LocalPlayer.CharacterAdded:Connect(function(char)
            local head = char:FindFirstChild("Head")
            if head and getgenv().Config.Headless then
               _G.PlayerCosmeticsCleanup.headTransparency = head.Transparency
               local decal = head:FindFirstChildOfClass("Decal")
               if decal then
                  _G.PlayerCosmeticsCleanup.faceDecalId = decal.Texture
                  _G.PlayerCosmeticsCleanup.faceDecalName = decal.Name
               end
            end
            saveRightLegProperties(char)
            applyKorblox(char)
         end)
         if getgenv().Config.Headless then
            headLoop = task.spawn(function()
               while CosmeticsActive do
                  local char = LocalPlayer.Character
                  if char then
                     local head = char:FindFirstChild("Head")
                     if head then
                        head.Transparency = 1
                        local decal = head:FindFirstChildOfClass("Decal")
                        if decal then
                           decal:Destroy()
                        end
                     end
                  end
                  task.wait(0.1)
               end
            end)
         end
      else
         CosmeticsActive = false
         if _G.PlayerCosmeticsCleanup.characterAddedConn then
            _G.PlayerCosmeticsCleanup.characterAddedConn:Disconnect()
            _G.PlayerCosmeticsCleanup.characterAddedConn = nil
         end
         if headLoop then
            task.cancel(headLoop)
            headLoop = nil
         end
         local char = LocalPlayer.Character
         if char then
            local head = char:FindFirstChild("Head")
            if head and _G.PlayerCosmeticsCleanup.headTransparency then
               head.Transparency = _G.PlayerCosmeticsCleanup.headTransparency
               if _G.PlayerCosmeticsCleanup.faceDecalId then
                  local newDecal = head:FindFirstChildOfClass("Decal") or Instance.new("Decal", head)
                  newDecal.Name = _G.PlayerCosmeticsCleanup.faceDecalName or "face"
                  newDecal.Texture = _G.PlayerCosmeticsCleanup.faceDecalId
                  newDecal.Face = Enum.NormalId.Front
               end
            end
            restoreRightLeg(char)
         end
         _G.PlayerCosmeticsCleanup = {}
      end
   end
})

-- Visuals Tab
local ESPSection = VisualsTab:CreateSection("ESP")
VisualsTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      espEnabled = value
      if value then
         for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
               local highlight = Instance.new("Highlight")
               highlight.Adornee = player.Character
               highlight.FillColor = Color3.new(1, 0, 0)
               highlight.OutlineColor = Color3.new(1, 1, 1)
               highlight.Parent = player.Character
               espConnections[player] = highlight
            end
         end
         espConnections["playerAdded"] = Players.PlayerAdded:Connect(function(player)
            if player ~= LocalPlayer then
               player.CharacterAdded:Connect(function(character)
                  local highlight = Instance.new("Highlight")
                  highlight.Adornee = character
                  highlight.FillColor = Color3.new(1, 0, 0)
                  highlight.OutlineColor = Color3.new(1, 1, 1)
                  highlight.Parent = character
                  espConnections[player] = highlight
               end)
            end
         end)
      else
         for _, highlight in pairs(espConnections) do
            if typeof(highlight) == "Instance" then
               highlight:Destroy()
            elseif highlight.Disconnect then
               highlight:Disconnect()
            end
         end
         espConnections = {}
      end
   end
})

local NameTagsSection = VisualsTab:CreateSection("Name Tags")
VisualsTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      nameTagsEnabled = value
      if value then
         for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
               local billboard = Instance.new("BillboardGui")
               billboard.Name = "NameTag"
               billboard.Size = UDim2.new(0, 200, 0, 50)
               billboard.StudsOffset = Vector3.new(0, 3, 0)
               billboard.AlwaysOnTop = true
               billboard.Adornee = player.Character:FindFirstChild("Head")
               billboard.Parent = player.Character

               local textLabel = Instance.new("TextLabel")
               textLabel.Size = UDim2.new(1, 0, 1, 0)
               textLabel.BackgroundTransparency = 1
               textLabel.Text = player.Name
               textLabel.TextColor3 = Color3.new(1, 1, 1)
               textLabel.TextStrokeTransparency = 0.5
               textLabel.Font = Enum.Font.SourceSansBold
               textLabel.TextSize = 18
               textLabel.Parent = billboard

               nameTagsConnections[player] = billboard
            end
         end
         nameTagsConnections["playerAdded"] = Players.PlayerAdded:Connect(function(player)
            if player ~= LocalPlayer then
               player.CharacterAdded:Connect(function(character)
                  local billboard = Instance.new("BillboardGui")
                  billboard.Name = "NameTag"
                  billboard.Size = UDim2.new(0, 200, 0, 50)
                  billboard.StudsOffset = Vector3.new(0, 3, 0)
                  billboard.AlwaysOnTop = true
                  billboard.Adornee = character:FindFirstChild("Head")
                  billboard.Parent = character

                  local textLabel = Instance.new("TextLabel")
                  textLabel.Size = UDim2.new(1, 0, 1, 0)
                  textLabel.BackgroundTransparency = 1
                  textLabel.Text = player.Name
                  textLabel.TextColor3 = Color3.new(1, 1, 1)
                  textLabel.TextStrokeTransparency = 0.5
                  textLabel.Font = Enum.Font.SourceSansBold
                  textLabel.TextSize = 18
                  textLabel.Parent = billboard

                  nameTagsConnections[player] = billboard
               end)
            end
         end)
      else
         for _, billboard in pairs(nameTagsConnections) do
            if typeof(billboard) == "Instance" then
               billboard:Destroy()
            elseif billboard.Disconnect then
               billboard:Disconnect()
            end
         end
         nameTagsConnections = {}
      end
   end
})

local ChamsSection = VisualsTab:CreateSection("Chams")
VisualsTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      chamsEnabled = value
      if value then
         for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
               for _, part in pairs(player.Character:GetDescendants()) do
                  if part:IsA("MeshPart") or part:IsA("Part") then
                     local cham = Instance.new("SurfaceGui")
                     cham.Name = "Cham"
                     cham.AlwaysOnTop = true
                     cham.Adornee = part
                     cham.Parent = part

                     local frame = Instance.new("Frame")
                     frame.Size = UDim2.new(1, 0, 1, 0)
                     frame.BackgroundColor3 = Color3.new(0, 1, 0)
                     frame.BackgroundTransparency = 0.5
                     frame.Parent = cham

                     chamsConnections[part] = cham
                  end
               end
            end
         end
         chamsConnections["playerAdded"] = Players.PlayerAdded:Connect(function(player)
            if player ~= LocalPlayer then
               player.CharacterAdded:Connect(function(character)
                  for _, part in pairs(character:GetDescendants()) do
                     if part:IsA("MeshPart") or part:IsA("Part") then
                        local cham = Instance.new("SurfaceGui")
                        cham.Name = "Cham"
                        cham.AlwaysOnTop = true
                        cham.Adornee = part
                        cham.Parent = part

                        local frame = Instance.new("Frame")
                        frame.Size = UDim2.new(1, 0, 1, 0)
                        frame.BackgroundColor3 = Color3.new(0, 1, 0)
                        frame.BackgroundTransparency = 0.5
                        frame.Parent = cham

                        chamsConnections[part] = cham
                     end
                  end
               end)
            end
         end)
      else
         for _, cham in pairs(chamsConnections) do
            if typeof(cham) == "Instance" then
               cham:Destroy()
            elseif cham.Disconnect then
               cham:Disconnect()
            end
         end
         chamsConnections = {}
      end
   end
})

local FullbrightSection = VisualsTab:CreateSection("Fullbright")
VisualsTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      fullbrightEnabled = value
      if value then
         Lighting.Brightness = 2
         Lighting.Ambient = Color3.new(1, 1, 1)
         Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
         Lighting.FogEnd = math.huge
      else
         Lighting.Brightness = originalLighting.Brightness
         Lighting.A fugient = originalLighting.Ambient
         Lighting.OutdoorAmbient = originalLighting.OutdoorAmbient
         Lighting.FogEnd = originalLighting.FogEnd
      end
   end
})

local CrosshairSection = VisualsTab:CreateSection("Crosshair")
VisualsTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      crosshairEnabled = value
      if value then
         if not crosshairGui then
            crosshairGui = Instance.new("ScreenGui")
            crosshairGui.Name = "CrosshairGui"
            crosshairGui.ResetOnSpawn = false
            crosshairGui.Parent = CoreGui

            local crosshairFrame = Instance.new("Frame")
            crosshairFrame.Size = UDim2.new(0, 20, 0, 2)
            crosshairFrame.Position = UDim2.new(0.5, -10, 0.5, -1)
            crosshairFrame.BackgroundColor3 = Color3.new(1, 0, 0)
            crosshairFrame.Parent = crosshairGui

            local crosshairFrame2 = Instance.new("Frame")
            crosshairFrame2.Size = UDim2.new(0, 2, 0, 20)
            crosshairFrame2.Position = UDim2.new(0.5, -1, 0.5, -10)
            crosshairFrame2.BackgroundColor3 = Color3.new(1, 0, 0)
            crosshairFrame2.Parent = crosshairGui
         end
      else
         if crosshairGui then
            crosshairGui:Destroy()
            crosshairGui = nil
         end
      end
   end
})

local EnvironmentSection = VisualsTab:CreateSection("Environment")
VisualsTab:CreateDropdown({
   Name = "Skybox",
   Options = {"Midnight", "Space", "Galaxy", "Christmas"},
   CurrentOption = "Midnight",
   Callback = function(value)
      applySkybox(value)
   end
})

VisualsTab:CreateDropdown({
   Name = "Shaders",
   Options = {"Mid Purple Day", "Mid Pink Day", "Mid Day", "Evening", "Night"},
   CurrentOption = "Mid Purple Day",
   Callback = function(value)
      applyShader(value)
   end
})

VisualsTab:CreateColorPicker({
   Name = "Sky Color",
   Color = Color3.new(1, 1, 1),
   Callback = function(value)
      applySkyColor(value)
   end
})

-- Misc Tab
local AnimationsSection = MiscTab:CreateSection("Animations")
MiscTab:CreateDropdown({
   Name = "Emote",
   Options = Emotes_Data,
   CurrentOption = Emotes_Data[1],
   Callback = function(value)
      Auto_Parry.Play_Animation(value)
   end
})

local MusicSection = MiscTab:CreateSection("Music Player")
MiscTab:CreateInput({
   Name = "Music ID",
   PlaceholderText = "Enter Music ID",
   RemoveTextAfterFocusLost = false,
   Callback = function(value)
      playMusic(value)
   end
})

MiscTab:CreateButton({
   Name = "Pause Music",
   Callback = function()
      pauseMusic()
   end
})

local HitSoundSection = MiscTab:CreateSection("Hit Sound")
MiscTab:CreateToggle({
   Name = "Enabled",
   CurrentValue = false,
   Callback = function(value)
      hit_Sound_Enabled = value
      if value then
         Connections_Manager['Hit Sound'] = Workspace.Balls.ChildAdded:Connect(function(ball)
            if ball:IsA("BasePart") and ball:GetAttribute("realBall") then
               local sound = Instance.new("Sound")
               sound.SoundId = "rbxassetid://9114317057"
               sound.Volume = 1
               sound.Parent = ball
               ball:GetAttributeChangedSignal("target"):Connect(function()
                  if ball:GetAttribute("target") == tostring(LocalPlayer) then
                     sound:Play()
                  end
               end)
            end
         end)
      else
         if Connections_Manager['Hit Sound'] then
            Connections_Manager['Hit Sound']:Disconnect()
            Connections_Manager['Hit Sound'] = nil
         end
      end
   end
})

-- New Utility Tab
local UtilitySection = UtilityTab:CreateSection("Utility Features")

UtilityTab:CreateButton({
   Name = "Rejoin Server",
   Callback = function()
      game:GetService("TeleportService"):Teleport(game.PlaceId, LocalPlayer)
   end
})

UtilityTab:CreateToggle({
   Name = "Auto Respawn",
   CurrentValue = false,
   Callback = function(value)
      if value then
         Connections_Manager['Auto Respawn'] = LocalPlayer.CharacterAdded:Connect(function()
            if LocalPlayer.Character:FindFirstChild("Humanoid") and LocalPlayer.Character.Humanoid.Health <= 0 then
               game:GetService("ReplicatedStorage").Remotes.Respawn:FireServer()
            end
         end)
      else
         if Connections_Manager['Auto Respawn'] then
            Connections_Manager['Auto Respawn']:Disconnect()
            Connections_Manager['Auto Respawn'] = nil
         end
      end
   end
})

UtilityTab:CreateInput({
   Name = "Chat Spam Message",
   PlaceholderText = "Enter message",
   RemoveTextAfterFocusLost = false,
   Callback = function(value)
      Flags.ChatSpamMessage = value
   end
})

UtilityTab:CreateToggle({
   Name = "Chat Spam",
   CurrentValue = false,
   Callback = function(value)
      if value then
         Connections_Manager['Chat Spam'] = RunService.Heartbeat:Connect(function()
            if Flags.ChatSpamMessage then
               game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(Flags.ChatSpamMessage, "All")
            end
         end)
      else
         if Connections_Manager['Chat Spam'] then
            Connections_Manager['Chat Spam']:Disconnect()
            Connections_Manager['Chat Spam'] = nil
         end
      end
   end
})

-- New Combat Tab
local CombatSection = CombatTab:CreateSection("Combat Enhancements")

local aimbotEnabled = false
CombatTab:CreateToggle({
   Name = "Aimbot",
   CurrentValue = false,
   Callback = function(value)
      aimbotEnabled = value
      if value then
         Connections_Manager['Aimbot'] = RunService.RenderStepped:Connect(function()
            local closestPlayer = nil
            local shortestDistance = math.huge
            for _, player in pairs(Players:GetPlayers()) do
               if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                  local distance = (LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                  if distance < shortestDistance then
                     shortestDistance = distance
                     closestPlayer = player
                  end
               end
            end
            if closestPlayer then
               Workspace.CurrentCamera.CFrame = CFrame.new(Workspace.CurrentCamera.CFrame.Position, closestPlayer.Character.HumanoidRootPart.Position)
            end
         end)
      else
         if Connections_Manager['Aimbot'] then
            Connections_Manager['Aimbot']:Disconnect()
            Connections_Manager['Aimbot'] = nil
         end
      end
   end
})

CombatTab:CreateButton({
   Name = "Kill All",
   Callback = function()
      for _, player in pairs(Players:GetPlayers()) do
         if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.Health = 0
         end
      end
   end
})

CombatTab:CreateToggle({
   Name = "Infinite Stamina",
   CurrentValue = false,
   Callback = function(value)
      if value then
         Connections_Manager['Infinite Stamina'] = RunService.Heartbeat:Connect(function()
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
               LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Running)
            end
         end)
      else
         if Connections_Manager['Infinite Stamina'] then
            Connections_Manager['Infinite Stamina']:Disconnect()
            Connections_Manager['Infinite Stamina'] = nil
         end
      end
   end
})

-- Cleanup on Script End
LocalPlayer.CharacterAdded:Connect(function(character)
   clientCharacter = character
   clientHumanoid = character:WaitForChild("Humanoid")
end)

game:BindToClose(function()
   for _, connection in pairs(Connections_Manager) do
      if connection then
         connection:Disconnect()
      end
   end
   Connections_Manager = {}
   if musicPlayer then
      musicPlayer:Destroy()
   end
   if currentSkybox then
      currentSkybox:Destroy()
   end
   if currentShader then
      currentShader:Destroy()
   end
   if skyColorConnection then
      skyColorConnection:Disconnect()
   end
   if crosshairGui then
      crosshairGui:Destroy()
   end
   if espEnabled then
      for _, highlight in pairs(espConnections) do
         if typeof(highlight) == "Instance" then
            highlight:Destroy()
         elseif highlight.Disconnect then
            highlight:Disconnect()
         end
      end
   end
   if nameTagsEnabled then
      for _, billboard in pairs(nameTagsConnections) do
         if typeof(billboard) == "Instance" then
            billboard:Destroy()
         elseif billboard.Disconnect then
            billboard:Disconnect()
         end
      end
   end
   if chamsEnabled then
      for _, cham in pairs(chamsConnections) do
         if typeof(cham) == "Instance" then
            cham:Destroy()
         elseif cham.Disconnect then
            cham:Disconnect()
         end
      end
   end
   if fullbrightEnabled then
      Lighting.Brightness = originalLighting.Brightness
      Lighting.Ambient = originalLighting.Ambient
      Lighting.OutdoorAmbient = originalLighting.OutdoorAmbient
      Lighting.FogEnd = originalLighting.FogEnd
   end
   if getgenv().spinThread then
      getgenv().spin = false
      getgenv().spinThread = nil
   end
   if getgenv().FOVLoop then
      getgenv().FOVLoop:Disconnect()
      getgenv().FOVLoop = nil
   end
   if CoreGui:FindFirstChild("ManualSpamUI") then
      CoreGui:FindFirstChild("ManualSpamUI"):Destroy()
   end
   if _G.PlayerCosmeticsCleanup.characterAddedConn then
      _G.PlayerCosmeticsCleanup.characterAddedConn:Disconnect()
   end
   if headLoop then
      task.cancel(headLoop)
   end
   local char = LocalPlayer.Character
   if char and _G.PlayerCosmeticsCleanup.headTransparency then
      local head = char:FindFirstChild("Head")
      if head then
         head.Transparency = _G.PlayerCosmeticsCleanup.headTransparency
         if _G.PlayerCosmeticsCleanup.faceDecalId then
            local newDecal = head:FindFirstChildOfClass("Decal") or Instance.new("Decal", head)
            newDecal.Name = _G.PlayerCosmeticsCleanup.faceDecalName or "face"
            newDecal.Texture = _G.PlayerCosmeticsCleanup.faceDecalId
            newDecal.Face = Enum.NormalId.Front
         end
      end
      restoreRightLeg(char)
   end
   _G.PlayerCosmeticsCleanup = {}
end)

Rayfield:LoadConfiguration()